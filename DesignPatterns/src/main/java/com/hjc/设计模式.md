* 1. 开闭原则（Open Closed Principle,OCP）:对扩展开放，对修改关闭（抽象约束、封装变化）
* 2. 里式替换原则（Liskov Substitution Principle,LSP）:继承必须保持超类所拥有的性质在子类中任然成立（子类可以扩展父类的功能，但不能改变父类原有的功能）
* 3. 依赖倒置原则（Dependence Inversion Principle,DIP）:高层模块不依赖于低层模块，两者都应该依赖于其抽象；抽象不依赖于细节，细节依赖抽象（通过面向接口编程来实现）
* 4. 单一职责原则（Single Responsibility Principle,SRP）:一个类应该有且仅有一个引起它变化的原因，否则应该拆分（控制类的粒度大小）
* 5. 接口隔离原则（Interface Segregation Principle,ISP）:一个类对另外一个类的依赖应该建立在最小接口上（客户端不应该被迫依赖于它不使用的方法）
* 6. 迪米特原则（Law of Demeter,LoD）:也叫做最少支持原则（Least Knowledge Principle,LKP）:如果两个软件无法直接通信，那就不应该发生直接的相互调用，而是通过第三方转发该调用（只和朋友说话，不和陌生人交谈）
* 7. 合成复用原则（Composite Reuse Principle）：在软件复用时，尽量先使用组合或者聚合等关系来实现，其次才考虑用继承关系来实现（通过将已有的对象纳入新的对象，作为新对象的成员对象来实现，新对象可以调用已有对象的功能）

创建型模式
|名称|学习难度(1-5)|使用频率(1-5)|
|:---|:---|:---|
|抽象工厂模式|4|5|
|工厂方法模式|2|5|
|单例模式|1|4|
|原型模式|3|3|
|简单工厂模式|2|3|
|建造者模式|4|2|

结构型模式
|名称|学习难度(1-5)|使用频率(1-5)|
|:---|:---|:---|
|外观模式|1|5|
|代理模式|3|4|
|组合模式|3|4|
|适配器模式|2|4|
|桥接模式|3|3|
|装饰模式|3|3|
|享元模式|4|1|


行为型模式
|名称|学习难度(1-5)|使用频率(1-5)|
|:---|:---|:---|
|观察者模式|3|5|
|迭代器模式|3|5|
|命令模式|3|4|
|策略者模式|1|4|
|状态模式|3|3|
|模板方法者模式|2|3|
|解释器模式|5|2|
|职责链模式|3|2|
|中介者模式|3|2|
|备忘录模式|2|2|
|访问者模式|4|1|
