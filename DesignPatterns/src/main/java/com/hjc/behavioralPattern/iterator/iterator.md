1. 迭代器模式（Iterator Pattern）：提供一个方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Curse）

2. 在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中一般会结合工厂方法模式应用

3. 迭代器模式具有以下几个角色：
    * Iterator（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历元素的方法
    * ConcreteIterator（具体迭代器）：实现了抽象迭代器的接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数
    * Aggregate（抽象聚合类）：用于存储和管理元素对象，声明一个createIterator()方法，用于创建一个迭代器对象，充当抽象迭代器工厂角色
    * ConcreteAggregate(具体聚合类)：实现了抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例

4. 在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一 个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些 没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。

5. 抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求， 尽量为各种遍历方法都提供声明，另一方面又不能包含太多方法，接口中方法太多将给子类 的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法 提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须 修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避 免之后修改接口。

6. 迭代器模式总结：
    * 迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚 合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程 语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等 语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。

7. 迭代器模式优点：
    * 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方 式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法， 我们也可以自己定义迭代器的子类以支持新的遍历方式。 
    * 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍 历等方法，这样可以简化聚合类的设计。 
    * 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原 有代码，满足“开闭原则”的要求

8. 迭代器模式缺点：
    * 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭 代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
    * 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器 Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现， 而ListIterator迭代器无法用于操作Set类型的聚合对象。

9. 迭代器模式适用场景：
    * 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储 分离，使得访问聚合对象时无须了解其内部实现细节。
    * 需要为一个聚合对象提供多种遍历方式。 
    * 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供 不同的遍历方式，而客户端可以一致性地操作该接口。