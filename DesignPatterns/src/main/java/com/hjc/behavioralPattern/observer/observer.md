1. 观察者模式（Observer Pattern）：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其他相关依赖对象都可以得到通知并被动更新

2. 观察者模式又叫做发布-订阅模式（Publish/Subscribe），模型-视图模式（Model/View），源-监听器模式（Source/Listener），从属者模式（Dependents）

3. 观察者模式包含以下几个角色：
    * Subject(目标/发布者/主题)：指被观察的对象，在subject中定义了一个观察者集合，一个subject可以接受任意数量的观察者来观察，它提供一系列方法来增加，删除观察者对象，同时定义了通知方法notify();subject可以是接口，也可以是抽象类或者具体类
    * ConcreteSubject（具体目标/具体发布者）：是Subject的子类
    * Observer（观察者/订阅者）：观察者将对观察目标的改变作出反应；一般定义为接口，该接口声明了更新数据的方法update();
4. ConcreteObserver(具体观察者/具体订阅者)：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者中定义的update()方法

5. 观察者模式在Java中非常重要。在JDK的java.util包中，提供了Observable类和Observer接口，他们构成了JDK对观察者模式的支持

6. mvc架构采用的就是观察者模式：model为发布者，view为订阅者，controller可充当两者间的中介者

7. 总结
    * 观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观 察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到 一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程 语言的GUI事件处理的实现，在基于事件的XML解析技术(如SAX2)以及Web事件处理中也 都使用了观察者模式。
8. 观察者模式的主要优点如下:
    * 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽 象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
    * 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象 观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因 此它们可以属于不同的抽象化层次。
    * 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对 多系统设计的难度。
    * 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体 观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。
9. 观察者模式的主要缺点如下:
    * 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时 间。    
    * 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可 能导致系统崩溃。
    * 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只 是知道观察目标发生了变化。
10. 适用场景 :
    * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的 对象中使它们可以各自独立地改变和复用。
    * 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发 生改变，也不知道这些对象是谁。
    * 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对 象......，可以使用观察者模式创建一种链式触发机制。
